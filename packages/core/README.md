# GraphQL Pagination - Core

Core module of GraphQL Pagination providing spec and ready to use implementations.

1. [CursorPager](src/CursorPagerSpec.ts) specification
2. [DataSource](src/datasource/DataSource.ts) specification
3. [DataSourcePager](src/DataSourcePager.ts) implementation as class or functional interface
4. [ArrayDataSource](src/datasource/ArrayDataSource.ts) implementation as fixed array of data
5. [OffsetDataSourceWrapper](src/datasource/OffsetDataSourceWrapper.ts) Offset pagination wrapper
6. [GraphQL Type Defs](src/TypeDefs.ts)

Check additional modules:
1. [@graphql-pagination/sql-knex](https://www.npmjs.com/package/@graphql-pagination/sql-knex) - SQL (Knex.js) DataSource

## DataSourcePager

DataSource Pager implements CursorPager backed by a DataSource. It's up to you to either use built-in `ArrayDataSource`
or implement your own.

Configuration:

1. `dataSource` (optional) - pass your datasource at pager creation or pass on resolver level via `forwardResolver` or `backwardResolver`.
2. `typeName` (optional) - name to generate GraphQL Pagination type defs like `BookConnection`, `BookEdge`.
3. `cursor` (optional) - custom implementation how to encode/decode cursor
4. `validateForwardArgs` (optional) - function (or array) to validate input args used by forward resolver
5. `validateBackwardArgs` (optional) - function (or array) to validate input args used by backward resolver
6. `fetchTotalCountInResolver` (optional) - if false then totalCount is not fetched as part of forward/backward resolvers
   but totalCount resolver in Connection object needs to be defined separately. Pager provides `.resolvers` field for it.
7. `typeDefDirectives` (optional) - directives added to generated type definitions.

See more details in [DataSourcePager.ts](./src/DataSourcePager.ts#19).

### Basic Example

```js
const { ArrayDataSource, DataSourcePager, dataSourcePager } = require("@graphql-pagination/core");

// Create Array Data Source from array of books
const ds = new ArrayDataSource(books);
// Functional way (preferred)
const pager = dataSourcePager({
    dataSource: ds,
    typeName: "Book",
});

// Class way
// const pager = new DataSourcePager({
//     dataSource: ds,
//     typeName: "Book",
// });

// BookConnection is generated by DataSourcePager
const typeDefs = gql`
    type Book {
        id: ID!
        title: String
        author: String
    }
    type Query {
        booksAsc(first: Int = 10 after: String): BookConnection
        booksDesc(last: Int = 10 before: String): BookConnection
    }
`;

const resolvers = {
    Query: {
        booksAsc: (_, args) => pager.forwardResolver(args),
        booksDesc: (_, args) => pager.backwardResolver(args),
    },
};
```

### Offset Data Source Paging

If your DS / API provides offset pagination resp. slicing (start + size) and you want to use this pagination then it's supported as wrapper.

You need to create your DS like any other but expect that Wrapper will store in encoded cursor the index value and not any field from your data.
Then `afterId` / `beforeId` values in your DS will be index (start) value.

#### Example

```js
const { ArrayDataSource, DataSourcePager, OffsetDataSourceWrapper } = require("@graphql-pagination/core");

class ArrayOffsetDs extends ArrayDataSource {

   async after(offset, size, args) {
      // No field data comparison involved. It's just offset slicing
      return this.getNodes(args).then(data => data.slice(offset, offset + size));
   }

}

const dsOffset = new ArrayOffsetDs(books, "_NOT_USED_");
const pagerOffset = new DataSourcePager({
   dataSource: new OffsetDataSourceWrapper(dsOffset),
   typeName: "Book",
});
```

### Complete Example

See fully working [examples/in-memory](../../examples/in-memory/index.js).

The complete example includes:

1. Input validation
2. Extra input args for data filtering
3. DataSource using Date type
4. OffsetDataSourceWrapper
5. Custom directives used in Type Objects
